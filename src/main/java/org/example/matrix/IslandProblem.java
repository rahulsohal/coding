package org.example.matrix;import java.util.LinkedList;import java.util.Queue;public class IslandProblem {    public static void main(String[] args) {        IslandProblem is = new IslandProblem();        System.out.println(is.noOfIslands());    }    boolean[][] visited;    final char LAND = '1';    final char WATER = '0';    public int noOfIslands() {        char[][] grid =                {{'1', '1', '1', '1', '0'},                {'1', '1', '0', '1', '0'},                {'1', '1', '0', '0', '0'},                {'0', '0', '0', '0', '0'}};        int m = grid.length;        int n = grid[0].length;        visited = new boolean[m][n];        int counter = 0;        for(int i=0;i<m;i++) {            for(int j=0;j<n;j++) {                if(grid[i][j] == LAND && !visited[i][j]) {                    bfs(i, j, grid, visited);                    counter++;                }            }        }        return counter;    }    public void bfs(int r, int c, char[][] grid, boolean[][] visited) {        int m = grid.length;        int n = grid[0].length;        int[][] directions = {{-1,0},{0,1},{1,0},{0,-1}};        Queue<int[]> queue = new LinkedList<>();        queue.offer(new int[] {r, c});        while (!queue.isEmpty()) {            int[] current = queue.poll();            int currRow = current[0];            int currCol = current[1];            for (int[] dir : directions) {                int newRow = currRow + dir[0];                int newCol = currCol + dir[1];                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] == LAND                       && !visited[newRow][newCol] ) {                    queue.offer(new int[]{newRow, newCol});                    visited[newRow][newCol] = true;                }            }        }    }}