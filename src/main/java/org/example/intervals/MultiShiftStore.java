package org.example.intervals;import java.util.*;public class MultiShiftStore {    private static int MIN_IN_A_DAY = 1440;    public static void main(String[] args) {        String[][] shifts = {                {"Store1", "John", "Bakery", "08:00", "10:00"},                {"Store1", "John", "Checkout", "10:00", "12:00"},                {"Store1", "John", "Dairy", "14:00", "19:00"},                {"Store1", "John", "Bakery", "22:00", "02:00"}, // crosses midnight                {"Store1", "Alice", "Bakery", "09:00", "11:00"},                {"Store1", "Alice", "Checkout", "10:30", "12:00"},                {"Store1", "Alice", "Dairy", "12:00", "14:00"},                {"Store1", "Alice", "Bakery", "15:00", "17:00"}        };        MultiShiftStore store = new MultiShiftStore();        System.out.println(store.mergeShiftsAllStore(shifts));    }    public Map<String, Map<String, List<String>>> mergeShiftsAllStore(String[][] shifts) {        Map<String, Map<String, List<Shift>>> storeMap = new LinkedHashMap<>();        for(String[] shift: shifts) {            String store = shift[0];            String employee = shift[1];            String startTime = shift[3];            String endTime = shift[4];            int start = convertTimeToMinutes(startTime);            int end = convertTimeToMinutes(endTime);            if(end< start) {                end+=MIN_IN_A_DAY;            }            storeMap.computeIfAbsent(store, k-> new HashMap<>())                    .computeIfAbsent(employee, k->new ArrayList<>())                    .add(new Shift(start,end));        }        System.out.println(storeMap);        Map<String, Map<String, List<String>>> result = new LinkedHashMap<>();        for(String store: storeMap.keySet()) {            Map<String, List<String>> empResult = new LinkedHashMap<>();            for(String emp: storeMap.get(store).keySet()) {                List<Shift> merged = mergeShifts(storeMap.get(store).get(emp));                List<String> formattedResult = new ArrayList<>();                for(Shift s: merged) {                    formattedResult.add(formatShift(s));                }                empResult.put(emp, formattedResult);            }            result.put(store, empResult);        }        return result;    }    private List<Shift> mergeShifts(List<Shift> shifts) {        if (shifts.isEmpty()) return Collections.emptyList();        shifts.sort(Comparator.comparingInt(Shift::getStart)                .thenComparing(Shift::getEnd));        List<Shift> result = new ArrayList<>();        Shift current = shifts.get(0);        for(int i=1;i<shifts.size();i++) {            Shift next = shifts.get(i);            if(next.start <= current.end) {                current.end = Math.max(current.end, next.end);            } else {                result.add(current);                current = next;            }        }        result.add(current);        return result;    }    private int convertTimeToMinutes(String time) {        int hours = Integer.parseInt(time.substring(0,2));        int mins = Integer.parseInt(time.substring(3));        return 60* hours + mins;    }    private String formatShift(Shift shift) {        return formatMinutes(shift.start) + " " + formatMinutes(shift.end);    }    private String formatMinutes(int totalMinutes) {        int dayOffset = totalMinutes/MIN_IN_A_DAY;        int minutesInDay = totalMinutes%MIN_IN_A_DAY;        int hour = minutesInDay/60;        int mins = minutesInDay%60;        if(dayOffset == 0) {            return String.format("%02d:%02d", hour, mins);        } else {            return String.format("%02d:%02d+%d", hour, mins, dayOffset);        }    }}