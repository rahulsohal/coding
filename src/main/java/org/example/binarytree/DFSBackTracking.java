package org.example.binarytree;import org.example.util.TreeNode;import java.util.Arrays;import java.util.LinkedList;import java.util.List;import java.util.Queue;public class DFSBackTracking {    int totalSum=0;    public static void main(String[] args) {        DFSBackTracking bt = new DFSBackTracking();        int[] nums = {113,215,221};        int numSum = bt.pathSum(nums);        System.out.println(STR."sum: \{numSum}");    }    // Path Sum IV: Given the values in array, provide the path sum after    public int pathSum(int[] nums) {        int[] nodes = new int[32];        Arrays.fill(nodes, -1);        List<Integer> list = List.of(1,2,3);        int[] arr = list.stream()                .mapToInt(Integer::intValue)                .toArray();        for(int num: nums) {            int depth = num / 100;            int pos = (num % 100) / 10;            int val = (num % 100) % 10;            int depthStartIndex = (int) (Math.pow(2, depth - 1) - 1);            int index = depthStartIndex + pos - 1;            nodes[index] = val;        }        TreeNode root = buildTree(nodes);        finalPathSum(root,0);        return totalSum;    }    private void finalPathSum(TreeNode node, int curSum) {        if(node == null)            return;        curSum+=node.val;        System.out.println(STR."sum : \{curSum}");        if(node.left == null && node.right == null) {            totalSum += curSum;        }        finalPathSum(node.left, curSum);        finalPathSum(node.right, curSum);    }    private TreeNode buildTree(int[] nodes) {        int nodeIndex = 1;        TreeNode root = new TreeNode(nodes[0], nodeIndex);        Queue<TreeNode> queue = new LinkedList<>();        queue.offer(root);        while(!queue.isEmpty() && nodeIndex < nodes.length) {            TreeNode node = queue.poll();            int leftNodeIndex = 2 * nodeIndex - 1;            int rightNodeIndex = 2 * nodeIndex;            if(leftNodeIndex < nodes.length && nodes[leftNodeIndex] != -1) {                node.left = new TreeNode(nodes[leftNodeIndex], leftNodeIndex + 1);                queue.add(node.left);                nodeIndex++;            }            if(rightNodeIndex < nodes.length && nodes[rightNodeIndex] != -1) {                node.right = new TreeNode(nodes[rightNodeIndex], rightNodeIndex + 1);                queue.add(node.right);                nodeIndex++;            }        }        return root;    }}