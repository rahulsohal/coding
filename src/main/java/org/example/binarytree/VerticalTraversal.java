package org.example.binarytree;import org.example.util.TreeNode;import java.util.*;public class VerticalTraversal {    public static void main(String[] args) {        int[] arr = {1,2,3,4,6,5,7};        VerticalTraversal vt = new VerticalTraversal();        TreeNode root = vt.buildTree(arr);        List<List<Integer>> res = vt.verticalTraversal(root);        System.out.println(res);    }    public List<List<Integer>> verticalTraversal(TreeNode root) {        List<int[]> nodes = new ArrayList<>();        dfs(root, 0, 0, nodes);        nodes.sort(new Comparator<int[]>() {            @Override            public int compare(int[] o1, int[] o2) {                if(o1[0] != o2[0])                    return Integer.compare(o1[0], o2[0]);                if(o1[1] != o2[1]) return Integer.compare(o1[1], o2[1]);                return Integer.compare(o1[2], o2[2]);            }        });        List<List<Integer>> res = new ArrayList<>();        if(root == null)            return res;        int prevCol = Integer.MIN_VALUE;        for(int[] curr: nodes) {            if(prevCol != curr[0]) {                prevCol = curr[0];                res.add(new ArrayList<>());            }            res.get(res.size() -1).add(curr[2]);        }        return res;    }    private static void dfs(TreeNode root, int col, int row, List<int[]> nodes) {        if(root == null)            return;        nodes.add(new int[]{col, row, root.val});        dfs(root.left, col-1, row+1, nodes);        dfs(root.right, col+1, row+1, nodes);    }    private TreeNode buildTree(int[] nodes) {        if(nodes.length == 0) return null;        TreeNode root = nodes[0] == -1 ? null : new TreeNode(nodes[0]);        Queue<TreeNode> queue = new LinkedList<>();        queue.offer(root);        int i =1;        while(!queue.isEmpty() && i < nodes.length ) {            TreeNode parent = queue.poll();            if(parent == null) continue;            if(i < nodes.length && nodes[i] != -1) {                parent.left = new TreeNode(nodes[i]);                queue.offer(parent.left);            }            i++;            if(i < nodes.length && nodes[i] != -1) {                parent.right = new TreeNode(nodes[i]);                queue.offer(parent.right);            }            i++;        }        return root;    }}